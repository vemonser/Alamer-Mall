"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const react_dom_1 = require("react-dom");
const constants_1 = require("./constants");
const useInViewport = (target, options = constants_1.defaultOptions, config = constants_1.defaultConfig, props = constants_1.defaultProps) => {
    const { onEnterViewport, onLeaveViewport } = props;
    const [, forceUpdate] = (0, react_1.useState)();
    const observer = (0, react_1.useRef)();
    const inViewportRef = (0, react_1.useRef)(false);
    const intersected = (0, react_1.useRef)(false);
    const enterCountRef = (0, react_1.useRef)(0);
    const leaveCountRef = (0, react_1.useRef)(0);
    function startObserver({ observerRef }) {
        const targetRef = target.current;
        if (targetRef) {
            const node = (0, react_dom_1.findDOMNode)(targetRef);
            if (node) {
                observerRef?.observe(node);
            }
        }
    }
    function stopObserver({ observerRef }) {
        const targetRef = target.current;
        if (targetRef) {
            const node = (0, react_dom_1.findDOMNode)(targetRef);
            if (node) {
                observerRef?.unobserve(node);
            }
        }
        observerRef?.disconnect();
        observer.current = null;
    }
    function handleIntersection(entries) {
        const entry = entries[0] || {};
        const { isIntersecting, intersectionRatio } = entry;
        const isInViewport = typeof isIntersecting !== 'undefined'
            ? isIntersecting
            : intersectionRatio > 0;
        // enter
        if (!intersected.current && isInViewport) {
            intersected.current = true;
            onEnterViewport?.();
            enterCountRef.current += 1;
            inViewportRef.current = isInViewport;
            forceUpdate(isInViewport);
            return;
        }
        // leave
        if (intersected.current && !isInViewport) {
            intersected.current = false;
            onLeaveViewport?.();
            if (config.disconnectOnLeave && observer.current) {
                // disconnect obsever on leave
                observer.current.disconnect();
            }
            leaveCountRef.current += 1;
            inViewportRef.current = isInViewport;
            forceUpdate(isInViewport);
        }
    }
    function initIntersectionObserver({ observerRef }) {
        if (!observerRef) {
            observer.current = new IntersectionObserver(handleIntersection, options);
            return observer.current;
        }
        return observerRef;
    }
    (0, react_1.useEffect)(() => {
        let observerRef = observer.current;
        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
        observerRef = initIntersectionObserver({ observerRef });
        startObserver({
            observerRef,
        });
        return () => {
            stopObserver({
                observerRef,
            });
        };
    }, [target.current, options, config, onEnterViewport, onLeaveViewport]);
    return {
        inViewport: inViewportRef.current,
        enterCount: enterCountRef.current,
        leaveCount: leaveCountRef.current,
    };
};
exports.default = useInViewport;
