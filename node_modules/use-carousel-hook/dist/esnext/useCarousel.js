"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const did_update_1 = __importDefault(require("@use-effect/did-update"));
const reducer_1 = __importDefault(require("./reducer"));
const useCarousel = (options = {}) => {
    const { direction = 'horizontal' } = options;
    const ref = options.initialRef ? options.initialRef : react_1.useRef(null);
    const [{ current, interaction }, dispatch] = react_1.useReducer(reducer_1.default, {
        current: 0,
        interaction: null
    });
    const [maxIndex, setMaxIndex] = react_1.useState(-1);
    // State to track whether the user is currently scrolling
    const [isUserScroll, setIsUserScroll] = react_1.useState(null);
    // Current position of the carousel
    const [position, setPosition] = react_1.useState({ isAtStart: true, isAtEnd: false });
    // Elements current in view
    const [inView, setInView] = react_1.useState([0]);
    const updateMaxIndex = react_1.useCallback(() => {
        if (!ref.current)
            return;
        const el = ref.current;
        const children = [...el.children];
        // If scrollWidth or scrollHeight is 0, return the children length
        if ((direction === 'vertical' && el.scrollHeight === 0) || el.scrollWidth === 0) {
            setMaxIndex(children.length - 1);
            return;
        }
        const lastScrollableChild = children.findIndex(child => {
            return direction === 'vertical'
                ? child.offsetTop >= el.scrollHeight - el.offsetHeight
                : child.offsetLeft >= el.scrollWidth - el.offsetWidth;
        });
        setMaxIndex(lastScrollableChild >= 0 ? lastScrollableChild : children.length - 1);
    }, [ref.current]);
    // Update in view state to find which elements are currently in the carousel view
    const updateInView = () => {
        if (!ref.current)
            return;
        const carouselEl = ref.current;
        const childEls = [...carouselEl.children];
        const currentChildEl = childEls[current];
        const inView = [current];
        const carouselBottom = currentChildEl.offsetTop + carouselEl.offsetHeight;
        const carouselRight = currentChildEl.offsetLeft + carouselEl.offsetWidth;
        // Find which elements are in view
        for (let index = current + 1; index < childEls.length; index++) {
            if (direction === 'vertical') {
                if (childEls[index].offsetTop + childEls[index].offsetHeight <= carouselBottom) {
                    inView.push(index);
                }
                else {
                    break;
                }
            }
            else {
                if (childEls[index].offsetLeft + childEls[index].offsetWidth <= carouselRight) {
                    inView.push(index);
                }
                else {
                    break;
                }
            }
        }
        setInView(inView);
    };
    // Update the current index while the user is scrolling
    const updateCurrentOnScroll = (carouselEl, current) => {
        for (let index = 0; index < carouselEl.children.length; index++) {
            const child = carouselEl.children[index];
            if ((direction === 'horizontal' && child.offsetLeft >= carouselEl.scrollLeft) ||
                (direction === 'vertical' && child.offsetTop >= carouselEl.scrollTop)) {
                if (index !== current) {
                    setCurrent(index, 'scroll');
                }
                break;
            }
        }
    };
    // Add events to handle setting of isUserScroll
    react_1.useEffect(() => {
        var _a, _b;
        const mouseDownHandler = () => setIsUserScroll(true);
        const mouseUpHandler = () => setIsUserScroll(false);
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('mousedown', mouseDownHandler);
        (_b = ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener('mouseup', mouseUpHandler);
        return () => {
            var _a, _b;
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('mousedown', mouseDownHandler);
            (_b = ref.current) === null || _b === void 0 ? void 0 : _b.removeEventListener('mouseup', mouseUpHandler);
        };
    }, []);
    // Attach listeners to update the maxIndex and inView state when resizing
    react_1.useEffect(() => {
        window.addEventListener('resize', updateMaxIndex);
        window.addEventListener('resize', updateInView);
        return () => {
            window.removeEventListener('resize', updateMaxIndex);
            window.removeEventListener('resize', updateInView);
        };
    }, [current]);
    react_1.useEffect(() => {
        var _a;
        // When current updates, attach a new event handler with the updated
        // current value to call updateCurrentOnScroll
        const scrollHandler = () => isUserScroll && ref.current && updateCurrentOnScroll(ref.current, current);
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.addEventListener('scroll', scrollHandler);
        return () => {
            var _a;
            (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', scrollHandler);
        };
    }, [current, isUserScroll]);
    // Update maxIndex inView state if the ref element changes
    react_1.useEffect(() => {
        updateMaxIndex();
        updateInView();
    }, [ref.current]);
    did_update_1.default(() => {
        if (!ref.current)
            return;
        // If interaction is scroll, the carousel doesn't need to handle the scrolling
        if (interaction !== 'scroll') {
            const carouselEl = ref.current;
            const currentChildEl = carouselEl.children[current];
            // Scroll to the element
            if (direction === 'vertical') {
                carouselEl.scrollTo({
                    top: currentChildEl.offsetTop,
                    behavior: options.scrollBehavior || 'smooth'
                });
            }
            else {
                carouselEl.scrollTo({
                    left: currentChildEl.offsetLeft,
                    behavior: options.scrollBehavior || 'smooth'
                });
            }
        }
        // Update the inView items
        updateInView();
        // Not a user scroll so set to false
        setIsUserScroll(false);
        // Update the carousel position
        setPosition({
            isAtStart: current === 0,
            isAtEnd: current === maxIndex
        });
    }, [current]);
    const previous = (amount = 1, interaction = 'button') => {
        dispatch({ type: 'decrement', amount, maxIndex, interaction });
    };
    const next = (amount = 1, interaction = 'button') => {
        dispatch({ type: 'increment', amount, maxIndex, interaction });
    };
    const setCurrent = (current, interaction = 'button') => {
        dispatch({ type: 'set', current, interaction });
    };
    const reset = () => {
        dispatch({ type: 'reset', interaction: null });
    };
    return {
        ref,
        previous,
        next,
        setCurrent,
        reset,
        position,
        current,
        inView
    };
};
exports.default = useCarousel;
